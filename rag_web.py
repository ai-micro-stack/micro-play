"""
Flask web application for the RAG (Retrieval-Augmented Generation) system.

This module provides a web interface for document upload, indexing, and Q&A functionality.
It includes REST API endpoints for querying the RAG system and administrative functions
for managing documents.
"""

import os
from flask import (
    Flask,
    request,
    send_from_directory,
    render_template,
    redirect,
    url_for,
    jsonify,
)
from plat.llmodel.llmodel_factory import LLModelFactory
from plat.vectordb.vectordb_factory import VectorDbFactory
from plat.embedding.embedding_factory import EmbeddingFactory
from rag_index import docIndex
from rerank.rerank_retrieved_docs import get_context_from_documents_with_query
from config import config
from logger import get_logger

logger = get_logger(__name__)


app = Flask(__name__)
os.makedirs(config.RAW_DOC_PATH, exist_ok=True)
app.config["RAW_DOC_PATH"] = config.RAW_DOC_PATH

# Initialize the retriever and LLM
llmodel_accessor = None
vectordb_accessor = None
embedding_accessor = None


def initialize_components():
    """Initialize the retriever and LLM components based on the current settings."""
    global llmodel_accessor, vectordb_accessor, embedding_accessor

    try:
        # choose the embedding model
        embedding_model = EmbeddingFactory(
            embedding_provider=config.EMBEDDING_PROVIDER, api_key=config.EMBEDDING_API_KEY
        )
        embedding_accessor = embedding_model.get_embedding_accessor()
        logger.info(f"Initialized embedding model: {config.EMBEDDING_PROVIDER}")

        # choose the vectordb model
        vectordb_model = VectorDbFactory(
            vectordb_provider=config.VECTORDB_PROVIDER,
            db_type=config.VECTORDB_TYPE,
            api_key=config.VECTORDB_API_KEY,
        )
        vectordb_accessor = vectordb_model.get_vectordb_accessor()
        vectordb_accessor.set_embedding_function(embedding_accessor)
        logger.info(f"Initialized vector database: {config.VECTORDB_TYPE}")

        # choose the llm model
        llm_model = LLModelFactory(
            llmodel_provider=config.LLM_MODEL_PROVIDER,
            model_name=config.LLM_MODEL_NAME,
            api_key=config.LLM_MODEL_API_KEY,
        )
        llmodel_accessor = llm_model.get_llmodel_accessor()
        logger.info(f"Initialized LLM model: {config.LLM_MODEL_PROVIDER}")

        logger.info(
            f"Components initialized - LLM: {config.LLM_MODEL_PROVIDER} | "
            f"Embed: {config.EMBEDDING_PROVIDER} | VDB: {config.VECTORDB_TYPE}"
        )

    except Exception as e:
        logger.error(f"Failed to initialize components: {e}")
        raise


@app.route("/")
def index():
    initialize_components()
    return render_template("index.html")


@app.route("/query", methods=["POST"])
def query():
    try:
        data = request.get_json()
        if not data or "query_text" not in data:
            logger.warning("Invalid request data received")
            return jsonify(error="Missing query_text in request"), 400

        query_text = data["query_text"].strip()
        if not query_text:
            logger.warning("Empty query received")
            return jsonify(error="Query text cannot be empty"), 400

        if len(query_text) > 1000:  # Reasonable limit
            logger.warning(f"Query too long: {len(query_text)} characters")
            return jsonify(error="Query text too long (max 1000 characters)"), 400

        logger.info(f"Processing query: '{query_text[:50]}...'")

        # Retrieve and rerank the results
        results = vectordb_accessor.search_similar_chunks(query_text, config.RETRIEVAL_DOCS)
        enhanced_context_text, sources = get_context_from_documents_with_query(query_text, results, config.RELEVANT_DOCS)

        # Generate response from LLM
        llm_response = llmodel_accessor.generate_response(
            context=enhanced_context_text, question=query_text
        )

        sources_html = "<br>".join(sources)
        response_text = f"{llm_response}<br><br><strong>Reference Doc Snippets:</strong><br>{sources_html}<br><br>(Response generated by {config.LLM_MODEL_PROVIDER} served LLM model: {config.LLM_MODEL_NAME})"

        logger.info(f"Query processed successfully - Found {len(results)} results")
        return jsonify(response=response_text)

    except Exception as e:
        logger.error(f"Error processing query: {e}")
        return jsonify(error="Internal server error"), 500


@app.route("/admin")
def admin():
    files = os.listdir(config.RAW_DOC_PATH)
    return render_template("admin.html", files=files)


@app.route("/upload", methods=["POST"])
def upload_file():
    try:
        if "file" not in request.files:
            logger.warning("No file part in upload request")
            return "No file part", 400

        file = request.files["file"]
        if file.filename == "":
            logger.warning("Empty filename in upload request")
            return "No selected file", 400

        # Validate file extension
        allowed_extensions = {'.pdf', '.txt', '.md', '.docx'}
        _, ext = os.path.splitext(file.filename.lower())
        if ext not in allowed_extensions:
            logger.warning(f"Invalid file extension: {ext}")
            return f"File type not allowed. Allowed types: {', '.join(allowed_extensions)}", 400

        # Check file size (10MB limit)
        file.seek(0, os.SEEK_END)
        file_size = file.tell()
        file.seek(0)
        if file_size > 10 * 1024 * 1024:
            logger.warning(f"File too large: {file_size} bytes")
            return "File too large (max 10MB)", 400

        file_path = os.path.join(config.RAW_DOC_PATH, file.filename)
        file.save(file_path)
        logger.info(f"File uploaded successfully: {file.filename}")
        return redirect(url_for("admin"))

    except Exception as e:
        logger.error(f"Error uploading file: {e}")
        return "Upload failed", 500


@app.route("/download/<filename>")
def download_file(filename):
    return send_from_directory(config.RAW_DOC_PATH, filename)


@app.route("/delete/<filename>", methods=["POST"])
def delete_file(filename):
    try:
        # Validate filename to prevent directory traversal
        if ".." in filename or "/" in filename or "\\" in filename:
            logger.warning(f"Invalid filename for deletion: {filename}")
            return "Invalid filename", 400

        file_path = os.path.join(config.RAW_DOC_PATH, filename)
        if os.path.exists(file_path):
            os.remove(file_path)
            logger.info(f"File deleted successfully: {filename}")
        else:
            logger.warning(f"File not found for deletion: {filename}")
        return redirect(url_for("admin"))

    except Exception as e:
        logger.error(f"Error deleting file {filename}: {e}")
        return "Delete failed", 500


@app.route('/index_docs', methods=['POST'])
def index_docs():
    try:
        logger.info("Starting document indexing process")
        docIndex()
        logger.info("Document indexing completed successfully")
        return jsonify({'message': 'Data loaded successfully!'})

    except Exception as e:
        logger.error(f"Error during document indexing: {e}")
        return jsonify({'error': 'Indexing failed'}), 500


@app.route('/goto_chat', methods=['GET', 'POST'])
def goto_chat():
    if request.method == 'POST':
        if 'button2' in request.form:
            initialize_components()
            return redirect(url_for("index"))


if __name__ == "__main__":
    initialize_components()
    app.run(host="0.0.0.0", port=8341, debug=True)
